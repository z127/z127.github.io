<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://example.com">
  <title>java虚拟机 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="- java虚拟机谈谈你对java的理解 平台无关性 GC 语言特性 面向对象 类库 异常处理  java如何实现平台无关性 编译时  运行时   java找不到主类在包下的类，在Java源文件的地方编译后，需要到最外层包的上一级目录下运行，而且类前面需要带包名，以.隔开。 查看字节码java -p 123456789101112131415161718192021222324Compiled f">
<meta property="og:type" content="article">
<meta property="og:title" content="java虚拟机">
<meta property="og:url" content="http://example.com/2021/08/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="- java虚拟机谈谈你对java的理解 平台无关性 GC 语言特性 面向对象 类库 异常处理  java如何实现平台无关性 编译时  运行时   java找不到主类在包下的类，在Java源文件的地方编译后，需要到最外层包的上一级目录下运行，而且类前面需要带包名，以.隔开。 查看字节码java -p 123456789101112131415161718192021222324Compiled f">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-08-21T13:51:39.982Z">
<meta property="article:modified_time" content="2021-08-21T14:25:58.512Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java虚拟机">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/main.css">

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/%E9%9A%8F%E7%AC%94">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/%E9%9A%8F%E7%AC%94">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-java虚拟机相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java虚拟机
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>-</p>
<h1 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h1><h2 id="谈谈你对java的理解"><a href="#谈谈你对java的理解" class="headerlink" title="谈谈你对java的理解"></a>谈谈你对java的理解</h2><ul>
<li>平台无关性</li>
<li>GC</li>
<li>语言特性</li>
<li>面向对象</li>
<li>类库</li>
<li>异常处理</li>
</ul>
<h2 id="java如何实现平台无关性"><a href="#java如何实现平台无关性" class="headerlink" title="java如何实现平台无关性"></a>java如何实现平台无关性</h2><ul>
<li><p>编译时</p>
</li>
<li><p>运行时</p>
</li>
</ul>
<h2 id="java找不到主类"><a href="#java找不到主类" class="headerlink" title="java找不到主类"></a>java找不到主类</h2><p>在包下的类，在Java源文件的地方编译后，需要到最外层包的上一级目录下运行，而且类前面需要带包名，以.隔开。</p>
<h2 id="查看字节码"><a href="#查看字节码" class="headerlink" title="查看字节码"></a>查看字节码</h2><p>java -p</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;test.java&quot;</span><br><span class="line">public class connector.test &#123;</span><br><span class="line">  public connector.test(); //这是一个无参构造函数</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 调用父类的构造方法</span><br><span class="line">       4: return                            // 退出构造函数</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_1                  //常量1放到栈顶</span><br><span class="line">       1: istore_1                  //将栈顶的值放到局部变量1中</span><br><span class="line">       2: iconst_1                  //将常量5放到栈顶</span><br><span class="line">       3: istore_2                  //将栈顶的值放到局部变量2中</span><br><span class="line">       4: iinc          1, 1        //将变量1加上1</span><br><span class="line">       7: iinc          2, 1        //将变量2加上1</span><br><span class="line">      10: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream; //静态变量加入1</span><br><span class="line">      13: iload_1                           //将变量1的值压入栈顶</span><br><span class="line">      14: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      17: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      20: iload_2</span><br><span class="line">      21: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      24: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.编写java文件，.java文件<br>2.生产字节码，就是.class文件。<br>3.有了.class文件，jvm加载JVM来进行执行</p>
<p>java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同的平台上运行时不需要进行编译，Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令</p>
<h2 id="jvm如何加载-class文件"><a href="#jvm如何加载-class文件" class="headerlink" title="jvm如何加载.class文件"></a>jvm如何加载.class文件</h2><ol>
<li>class loader：依据特定格式，加载class文件到内存</li>
<li>execution Engine:对命令进行解析</li>
<li>Native Interface：融合不同的开发语言的原生库为java所用</li>
<li>Runtime Data Area:JVM内存结构模式</li>
</ol>
<p>主要是由class loader将符合规范的class文件加载到内存，然后通过execution engine来进行解析，最后提交给本地接口来进行使用</p>
<h2 id="谈谈反射"><a href="#谈谈反射" class="headerlink" title="谈谈反射"></a>谈谈反射</h2><p>java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。这种动态获取信息以及动态调用对象的方法的功能称为java语言的反射机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class clazz=Class.forName(&quot;basic.reflection.Robot&quot;);</span><br><span class="line">Robot   r=(Robot)clazz.newInstance();</span><br><span class="line">System.out.println(&quot;class name is &quot;+clazz.getName());</span><br><span class="line">Method getHello=clazz.getDeclaredMethod(&quot;helloPerson&quot;,String.class);</span><br><span class="line">getHello.setAccessible(true);</span><br><span class="line">Object str=getHello.invoke(r,&quot;Bob&quot;);</span><br><span class="line">System.out.println(&quot;getHello result is &quot; +str);</span><br><span class="line">Method printName=clazz.getMethod(&quot;printName&quot;,String.class);</span><br><span class="line">printName.invoke(r,&quot;wangming&quot;);</span><br><span class="line">Field name=clazz.getDeclaredField(&quot;name&quot;);</span><br><span class="line">name.setAccessible(true);</span><br><span class="line">name.set(r,&quot;Alice&quot;);</span><br><span class="line">printName.setAccessible(true);</span><br><span class="line">printName.invoke(r,&quot;welcome&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="getmethod和-getdeclearmethod区别"><a href="#getmethod和-getdeclearmethod区别" class="headerlink" title="getmethod和 getdeclearmethod区别"></a>getmethod和 getdeclearmethod区别</h3><p>getDeclaredMethod：获取当前类的所有声明的方法，包括public、protected和private修饰的方法。需要注意的是，这些方法一定是在当前类中声明的，从父类中继承的不算，实现接口的方法由于有声明所以包括在内。</p>
<p>getMethod：获取当前类和父类的所有public的方法。这里的父类，指的是继承层次中的所有父类。比如说，A继承B，B继承C，那么B和C都属于A的父类。</p>
<h3 id="类从编译到执行的过程"><a href="#类从编译到执行的过程" class="headerlink" title="类从编译到执行的过程"></a>类从编译到执行的过程</h3><ol>
<li>编译器将Robot.java源文件编译为Robot.class字节码文件</li>
<li>类加载器将字节码转换为JVM中的Class<Robot>对象</li>
</ol>
<h3 id="类加载器-class-Loader"><a href="#类加载器-class-Loader" class="headerlink" title="类加载器(class Loader)"></a>类加载器(class Loader)</h3><ol>
<li>ClassLoader主要在Class的装载阶段,主要作用是从系统获得Class二级制数据流。它是Java的核心组件，所有的Class是由classLoader来进行加载的。classloader负责通过将class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化操作。</li>
</ol>
<h4 id="ClassLoaderd的种类"><a href="#ClassLoaderd的种类" class="headerlink" title="ClassLoaderd的种类"></a>ClassLoaderd的种类</h4><ul>
<li>BootStrapClassLoader:C++编写,加载核心库java.*</li>
<li>ExtClassLoader：Java编写，加载扩展库javax.*</li>
<li>AppClassLoader: Java编写,加载程序所在目录</li>
<li>自定义classLoader:java编写,定制化加载</li>
</ul>
<h5 id="自定义ClassLoader的实现"><a href="#自定义ClassLoader的实现" class="headerlink" title="自定义ClassLoader的实现"></a>自定义ClassLoader的实现</h5><ul>
<li>findclass </li>
<li>修改二进制流的代码，给类添加点信息。asm</li>
<li>字节码</li>
<li>AOP</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends  ClassLoader &#123;</span><br><span class="line">    private  String path;</span><br><span class="line">    private String classLoaderName;</span><br><span class="line">    public  MyClassLoader(String path,String classLoaderName)&#123;</span><br><span class="line">        this.path=path;</span><br><span class="line">        this.classLoaderName=classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line">    //用于寻找类文件</span><br><span class="line">    @Override</span><br><span class="line">    public  Class findClass(String name)&#123;</span><br><span class="line">        byte[] b=loadClassData(name);</span><br><span class="line">        return  defineClass(name,b,0,b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //用于加载类文件</span><br><span class="line">    private byte[] loadClassData(String name) &#123;</span><br><span class="line">        name=path+name+&quot;.class&quot;;</span><br><span class="line">        InputStream in =null;</span><br><span class="line">        ByteArrayOutputStream out=null;</span><br><span class="line">        try&#123;</span><br><span class="line">            in=new FileInputStream(new File(name));</span><br><span class="line">            out=new ByteArrayOutputStream();</span><br><span class="line">            int i=0;</span><br><span class="line">            while ((i=in.read())!=-1)</span><br><span class="line">            &#123;</span><br><span class="line">                out.write(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                out.close();</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; catch (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return  out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="谈谈类的加载器的双亲委派机制"><a href="#谈谈类的加载器的双亲委派机制" class="headerlink" title="谈谈类的加载器的双亲委派机制"></a>谈谈类的加载器的双亲委派机制</h2><p>1.自底向上检查类是否已经加载<br>2.自顶向下尝试加载类</p>
<p>有可能多个线程加载同一个类，所以会加一个同步锁</p>
<p>主要是发生在loadclass这个方法中，首先先加个锁，然后判断findloadedclass，当前类是否已经加载，如果为空的话就判断parent是否存在。parent是app-classloader.app-classloader，app-classloader又会调用这个loadclass这个方法。去看看app-classloader是否已经装载过。判断parent是否存在，如果存在的话  就掉用app-classloader的父类，extclass-loader。如果依旧没有装载的话，就继续判断parent是否存在，因为bootstrapclasscloader是用C++写的。肯定为空，就直接调用findbootstrapclass方法。如果findbootstrap这个方法还没有的，他就自己去调用findclass方法。<br>java6</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            // First, check if the class has already been loaded</span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t0 = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent != null) &#123;</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                    // ClassNotFoundException thrown if class not found</span><br><span class="line">                    // from the non-null parent class loader</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == null) &#123;</span><br><span class="line">                    // If still not found, then invoke findClass in order</span><br><span class="line">                    // to find the class.</span><br><span class="line">                    long t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    // this is the defining class loader; record the stats</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么要使用双亲委派机制去加载类"><a href="#为什么要使用双亲委派机制去加载类" class="headerlink" title="为什么要使用双亲委派机制去加载类"></a>为什么要使用双亲委派机制去加载类</h3><ul>
<li>避免多分同样字节码的加载</li>
<li></li>
</ul>
<p>JDK代码闭源， openjdk开源。</p>
<p>hg.oepnjdk.java.net/jdk8u/jdk8u/jdk/file</p>
<h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><ul>
<li>隐式加载:new</li>
<li>显示加载:loadClass,forName等。</li>
</ul>
<h3 id="loadCLass和forName的区别"><a href="#loadCLass和forName的区别" class="headerlink" title="loadCLass和forName的区别"></a>loadCLass和forName的区别</h3><p>类的装载过程</p>
<ul>
<li>加载<br>通过ClassLoader加载class文件字节码，生成Class对象</li>
<li>链接 <pre><code> 1. 校验：检查加载的class的正确性和安全性
 2. 准备：为类变量（static）分配存储空间并设置类变量初始值
 3. 解析: JVM将常量池内的符号引用转换为直接引用
</code></pre>
</li>
<li>解析<br> 执行类变量赋值和静态代码块</li>
</ul>
<ol>
<li>loadclass是加载类，是在链接之前。是还没有进行连接的。只完成了加载，链接和解析都完成了。loadclass在spring AOC 要读取一些配置的时候，如果是以classpath的方式来。 和spring aoc的lazy loading有关。spring aoc为了加快这个加载速度，大量使用延迟加载技术。使用classloader不需要使用链接和解析等步骤。这样可以加快加载速度</li>
<li>class.forname得到的class是已经初始化完成之后的。要使用静态代码块，一般使用forname</li>
</ol>
<h2 id="JAVA内存模型"><a href="#JAVA内存模型" class="headerlink" title="JAVA内存模型"></a>JAVA内存模型</h2><pre><code>线程私有和线程共享
- 线程私有:程序计数器、虚拟机栈、本地方法栈
- 线程共享:MetaSpace、Java堆 
</code></pre>
<ul>
<li><p>线程的私有区域<br>  程序计数器 </p>
<ul>
<li>当前线程锁执行的字节码行号指示器(逻辑)，逻辑计数器</li>
<li>改变计数器的值来选取吓一跳需要执行的字节码指令</li>
<li>和线程是一对的关系及”线程私有”</li>
<li>对java方法计数，如果是Native方法则计数器值为Undefined</li>
<li>不会发送内存泄露</li>
</ul>
<p>  Java虚拟机栈(Stack)</p>
<ul>
<li>Java方法执行的内存模型</li>
<li>包含多个栈帧- 局部变量表 :包含方法执行过程中的所有变量<pre><code>          操作数栈:入栈、出栈、复制、交换、产生消费变量
</code></pre>
</li>
</ul>
<p>  javap verbose 口语化来描述.class文件。<br>  istore 是从操作数栈到局部变量表<br>  iload 是从局部变量表load到操作数栈</p>
</li>
<li><p>本地方法栈</p>
<ul>
<li>与虚拟机栈类似，主要作用于标注了native的方法</li>
</ul>
</li>
<li><p>线程的共享区域</p>
</li>
</ul>
<p>1.6才有永久代，1.8没有永久代</p>
<ul>
<li><p>元空间(metaspace)与永久代(PermGen)的区别<br>元空间使用本地内存,而永久代使用的是JVM的内存</p>
<h3 id="MetaSpace相比PermGen的优势"><a href="#MetaSpace相比PermGen的优势" class="headerlink" title="MetaSpace相比PermGen的优势"></a>MetaSpace相比PermGen的优势</h3></li>
<li><p>字符串常量池存在永久代中，容易出现性能问和内存溢出</p>
</li>
<li><p>类和方法信息大小难易确定,给永久代的大小指定带来困难</p>
</li>
<li><p>永久代会为GC带来不必要的复杂性</p>
</li>
<li><p>方便hotspot与其他JVM如Jrockit的集成</p>
</li>
<li><p>Java堆(Heap)</p>
<ul>
<li>对象实例的分配区域</li>
<li>GC管理的主要区域</li>
</ul>
</li>
<li><p>metaspace(元空间)  </p>
</li>
</ul>
<h3 id="JVM三大性能调优参数-Xms-Xmx-Xss的含义"><a href="#JVM三大性能调优参数-Xms-Xmx-Xss的含义" class="headerlink" title="JVM三大性能调优参数-Xms -Xmx -Xss的含义"></a>JVM三大性能调优参数-Xms -Xmx -Xss的含义</h3><pre><code>- Xss:规定了每个线程虚拟机栈(堆栈)的大小
- Xms：堆的初始值
- Xmx: 堆能达到的最大值
</code></pre>
<h3 id="Java内存模式中堆和栈的区别"><a href="#Java内存模式中堆和栈的区别" class="headerlink" title="Java内存模式中堆和栈的区别"></a>Java内存模式中堆和栈的区别</h3><ol>
<li>内存分配策略</li>
</ol>
<ul>
<li>静态存储：编译时确定每个数据目标在运行时的存储空间需求</li>
<li>栈式存储:数据区需要在编译时未知，运行时模块入口前确定</li>
<li>堆式存储:编译时或运行时候模块入口都无法确定，动态分配</li>
</ul>
<ol start="2">
<li>联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址</li>
<li>管理方式:栈自动释放，堆需要GC</li>
<li>空间:栈比堆小 </li>
<li>碎片相关:栈产生的碎片远小于堆</li>
<li>分配方式:栈支持静态和动态分配,而堆仅支持动态分配</li>
<li>效率:栈的效率比堆高</li>
</ol>
<p>不同JDK版本之间的Intern()方法的区别–JDK6 VS JDK 6+</p>
<p>JDK6:当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回池种的该字符串的引用。否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用。</p>
<p>JDK6+ ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;1&quot;);  </span><br><span class="line">String s2 = &quot;1&quot;;  </span><br><span class="line">s.intern();  </span><br><span class="line">System.out.println(s == s2);  </span><br><span class="line">String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);  </span><br><span class="line">String s4 = &quot;11&quot;;  </span><br><span class="line">s3.intern();  </span><br><span class="line">System.out.println(s3 == s4);  </span><br><span class="line">String s = newString(&quot;1&quot;)，生成了常量池中的“1” 和堆空间中的字符串对象。</span><br><span class="line">String s2 = &quot;1&quot;，这行代码是生成一个s2的引用指向常量池中的“1”对象，但是发现已经存在了，那么就直接指向了它。</span><br><span class="line"></span><br><span class="line">s.intern()，这一行在这里就没什么实际作用了。因为&quot;1&quot;已经存在了。</span><br><span class="line">结果就是 s 和 s2 的引用地址明显不同。因此返回了false。</span><br><span class="line">String s3 = new String(&quot;1&quot;) + newString(&quot;1&quot;)，这行代码在字符串常量池中生成“1” ，并在堆空间中生成s3引用指向的对象（内容为&quot;11&quot;）。注意此时常量池中是没有 “11”对象的。</span><br><span class="line">String s4 = &quot;11&quot;， 这一行代码会直接去生成常量池中的&quot;11&quot;。</span><br><span class="line">s3.intern()，这一行在这里就没什么实际作用了。因为&quot;11&quot;已经存在了。</span><br></pre></td></tr></table></figure>
<p><code>JDK 6以后是能够把常量池的引用放进去，jdk6以前是只能放副本进去,放引用的话地址就有可能一样</code></p>
<p>结果就是 s3 和 s4 的引用地址明显不同。因此返回了false<br>和堆空间中的字符串对象。当调用intern方法时候，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，如果该字符串对象已经存在于JAVA堆中，则将堆中堆此对象的引用添加到字符串常量池中，并且返回该引用。如果堆中不存在，则在池中创建该字符串并返回其引用。</p>
<h3 id="字符串常量池在-Java-内存区域的哪个位置"><a href="#字符串常量池在-Java-内存区域的哪个位置" class="headerlink" title="字符串常量池在 Java 内存区域的哪个位置"></a>字符串常量池在 Java 内存区域的哪个位置</h3><ol>
<li>在 JDK6.0 及之前版本，字符串常量池是放在 Perm Gen 区(也就是方法区)中，此时常量池中存储的是对象。</li>
<li>在 JDK7.0 版本，字符串常量池被移到了堆中了。此时常量池存储的就是引用了。在 JDK8.0 中，永久代（方法区）被元空间取代了。</li>
</ol>
<h2 id="JAVA-垃圾回收机制"><a href="#JAVA-垃圾回收机制" class="headerlink" title="JAVA 垃圾回收机制"></a>JAVA 垃圾回收机制</h2><h3 id="判定对象是否被回收的依据"><a href="#判定对象是否被回收的依据" class="headerlink" title="判定对象是否被回收的依据"></a>判定对象是否被回收的依据</h3><ul>
<li>引用计数法<ol>
<li>通过判断对象的引用数量来决定对象是否可以被回收</li>
<li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</li>
<li>任何引用计数为0的对象实例可以被当做垃圾收集</li>
<li>执行效率比较高，程序执行受影响较小。无法检测出循环引用的情况，导致内存泄露</li>
</ol>
</li>
<li>可达性分析算法<ol>
<li>通过判断对象的引用链是否可达来决定对象是否可以被回收</li>
<li>判断GC ROOT对象和该对象是否关联。如果是关联的就代表可达.</li>
<li>可以作为GC ROOT的对象<ol>
<li>虚拟机栈中引用的对象(栈帧中的本地变量表)</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>本地方法栈中JNI(Native方法)的引用对象</li>
<li>活跃线程的引用对象</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="几种垃圾回收算法"><a href="#几种垃圾回收算法" class="headerlink" title="几种垃圾回收算法"></a>几种垃圾回收算法</h3><h4 id="标记-清除算法-Mark-and-Sweep"><a href="#标记-清除算法-Mark-and-Sweep" class="headerlink" title="标记-清除算法(Mark and Sweep)"></a>标记-清除算法(Mark and Sweep)</h4><ol>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除: 对堆内存从头到尾进行线性遍历，回收不可达对象内存。</li>
<li>缺点：碎片化</li>
</ol>
<h4 id="复制算法-copying-适合青年代"><a href="#复制算法-copying-适合青年代" class="headerlink" title="复制算法(copying)-适合青年代"></a>复制算法(copying)-适合青年代</h4><ol>
<li>分为对象块和空闲块</li>
<li>对象在对象快上创建</li>
<li>存活的对象被从对象块复制到空闲块上</li>
<li>将对象块所有对象内存进行清除</li>
<li>优点<ol>
<li>解决了碎片化问题</li>
<li>顺序分配内存，简单高效</li>
<li>适用于对象存活率低的场景，在青年代</li>
</ol>
</li>
</ol>
<h4 id="标记-整理算法-Compacting-适合老年代"><a href="#标记-整理算法-Compacting-适合老年代" class="headerlink" title="标记-整理算法(Compacting)-适合老年代"></a>标记-整理算法(Compacting)-适合老年代</h4><ol>
<li>标记：从根集合进行扫描，对存活的对象进行标记</li>
<li>清除：移动所有存活的对象，<code>且按照内存地址次序依次排列</code>，然后将末端内存地址以后的内存全部回收。不分对象快和内存块</li>
<li>缺点：移动成本高</li>
<li>优点<ol>
<li>避免内存的不连续行</li>
<li>不用设置两块内存互换</li>
<li>适用于老年代的场景</li>
</ol>
</li>
</ol>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ol>
<li>垃圾回收算法的组合拳</li>
<li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li>
<li>目的：提高加垃圾回收的效率</li>
</ol>
<h5 id="GC的分类"><a href="#GC的分类" class="headerlink" title="GC的分类"></a>GC的分类</h5><ol>
<li>年轻代</li>
</ol>
<ul>
<li>GC方式:Minor GC<ol>
<li>复制算法</li>
</ol>
</li>
</ul>
<ol start="2">
<li>年轻代： 尽可能快速收集掉那些生命周期短的对象<ul>
<li>Eden区:伊甸园,初始，如果eden区放不下 就放在 survivor区 8/10 份</li>
<li>两个Survivor区，from区和to区是可以相互转换的：<ul>
<li> from区 1/10</li>
<li> to 区  1/10</li>
</ul>
</li>
<li>年轻代占用堆1/3</li>
<li>MaxTenuringThrehold</li>
</ul>
</li>
<li>老年代<br> -GC方式：Full GC和Major GC<pre><code> - 标记清理算法
 - 标记整理算法
</code></pre>
 Full GC比Minor GC 慢，但执行频率低</li>
</ol>
<h5 id="触发FULL-GC的条件"><a href="#触发FULL-GC的条件" class="headerlink" title="触发FULL GC的条件"></a>触发FULL GC的条件</h5><ol>
<li>老年代的空间不足</li>
<li>永久代空间不足</li>
<li>CMS GC时出现 promotion failed,concurrent mode failure</li>
<li>Minor GC晋级到老年代的平均大小大于老年代的剩余空间</li>
<li>调用system.gc()</li>
<li>使用RMI来进行RPC或管理的JDK应用,每小时执行1次FULL GC</li>
</ol>
<h5 id="对象如何晋升到老年代"><a href="#对象如何晋升到老年代" class="headerlink" title="对象如何晋升到老年代"></a>对象如何晋升到老年代</h5><ol>
<li>经历一定Minor GC次数依然存活的对象</li>
<li>Survivor区中存放不下的对象</li>
<li>新生成的大对象(-xx :+PreenureSizeThreshold)</li>
</ol>
<h5 id="常用的性能调优的参数"><a href="#常用的性能调优的参数" class="headerlink" title="常用的性能调优的参数"></a>常用的性能调优的参数</h5><ol>
<li>-XX:SurvovorRatio:Eden和Survivor,默认8:1</li>
<li>-XX:NewRatio:老年代和年轻代内存大小的比例</li>
<li>-XX:MaxTenuringThreshold:对象从年轻代晋升到老年代经过GC次数的最大阈值</li>
</ol>
<h5 id="STOP-THE-World"><a href="#STOP-THE-World" class="headerlink" title="STOP-THE-World"></a>STOP-THE-World</h5><pre><code>1. JVM由于要执行GC而停止了应用程序的执行
2. 任何一种GC算法都会发生
3. 多数GC优化通过减少Stop-the-world发生的时间来提高程序性能
</code></pre>
<h5 id="safepoint"><a href="#safepoint" class="headerlink" title="safepoint"></a>safepoint</h5><pre><code>1. 分析过程中对象引用关系不会发生变化的点
2. 产生Safepoint的地方:方法调用;循环跳转;异常跳转等
3. 安全点数量得适中
</code></pre>
<h5 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h5><p>JVM的运行模式</p>
<ul>
<li>server<ul>
<li>启动慢，但是使用要比client块。</li>
</ul>
</li>
<li>client<ul>
<li>启动块，但是使用比server慢</li>
</ul>
</li>
</ul>
<h5 id="年轻代常见的垃圾收集器"><a href="#年轻代常见的垃圾收集器" class="headerlink" title="年轻代常见的垃圾收集器"></a>年轻代常见的垃圾收集器</h5><ul>
<li><p>Serial收集器(-XX:+UseSerialGC,复制算法)</p>
<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的年轻代收集器</li>
</ul>
</li>
<li><p>ParNew收集器(-xx:+UseParNewGC,复制算法)</p>
<ul>
<li>多线程收集，其余的行为、特定和Serial收集器一样</li>
<li>单核执行效率不如Serial,在多核执行才有优势</li>
</ul>
</li>
<li><p>Paralle Scavenge收集器（-xx:+UseParallelGC,复制算法）</p>
<ul>
<li>吞吐量=运行用户代码的时间/(运行用户代码时间+垃圾收集时间)</li>
<li>比起关注用户线程停顿时间，更关注系统的吞吐量</li>
<li>在多核执行才有优势，Server模式下默认的年轻代收集器</li>
<li>-XX:+UseAdaptiveSizePolicy</li>
</ul>
</li>
</ul>
<h5 id="老年代常见的垃圾收集器"><a href="#老年代常见的垃圾收集器" class="headerlink" title="老年代常见的垃圾收集器"></a>老年代常见的垃圾收集器</h5><ul>
<li><p>Serial Old收集器</p>
<ul>
<li>单线程收集，进行垃圾收集时，必须暂停所有工作线程</li>
<li>简单高效，Client模式下默认的老年代代收集器</li>
</ul>
</li>
<li><p>Parallel Old收集器(-xx:+UseParallelOldGC,标记整理算法)</p>
<ul>
<li>多线程收集，吞吐量优先</li>
</ul>
</li>
<li><p>CMS收集器(-xx:+UseConcMarkSweepGc,标记-清除算法)</p>
<ul>
<li><p>硬件厉害，建议CMS</p>
</li>
<li><p><code>初始化标记:STOP-the-world，只查看直接关联GC root的对象</code></p>
</li>
<li><p>并发标记:并发追溯标记，程序不会停顿</p>
</li>
<li><p>并发预清理：查找执行并发标记节点从年轻代晋级到老年代的对象，减少下一阶段标记的工作量</p>
</li>
<li><p><code>重新标记:STOP-THE-WORLD,暂停虚拟机,扫描CMS堆中的剩余对象</code></p>
</li>
<li><p>并发清理:清理垃圾对象，程序不会停顿</p>
</li>
<li><p>并发重置:重置CMS的数据结构</p>
</li>
</ul>
</li>
</ul>
<p>垃圾的产生如果在标记后产生，就只能等到下次再清理。标记清除算法。会出现内存空间碎片化的问题</p>
<p>G1收集器(-XX:+UseG1Gc,复制+标记-整理算法)</p>
<ul>
<li>并行和并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿</li>
</ul>
<p> garbage First收集器</p>
<ul>
<li>将整个Java对内存划分为多个大小相等的region</li>
<li>年轻代和老年代不再物理隔离</li>
</ul>
<h4 id="object的finalize-方法的作用是否与C-的析构函数作用相同"><a href="#object的finalize-方法的作用是否与C-的析构函数作用相同" class="headerlink" title="object的finalize()方法的作用是否与C++的析构函数作用相同"></a>object的finalize()方法的作用是否与C++的析构函数作用相同</h4><pre><code>- 与c++的析构函数不同，析构函数调用确定，而它是不确定的
- 将未引用的对象放置于F-Queue队列
- 方法执行随时可能会被终止
- 给与对象最后一次重生的机会
</code></pre>
<h4 id="java中的强引用、软引用，弱应用，虚应用"><a href="#java中的强引用、软引用，弱应用，虚应用" class="headerlink" title="java中的强引用、软引用，弱应用，虚应用"></a>java中的强引用、软引用，弱应用，虚应用</h4><pre><code>    强引用：new ，即时oom也不会回收
    软引用：对象处在有用非必须的状态,只有当内存空间不足时，GC会回收该引用的对象内存。用来实现高速缓存。
    弱引用:非必须的对象，比软应用更弱一些。GC时会被回收。
    虚引用:跟踪对象被垃圾收集器回收的活动，起哨兵作用，必须和referenceQueue联合使用

引用队列(referenceQueue)
- 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达
- 存储关联的且被GC的软引用,弱引用以及虚引用
</code></pre>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2021/08/21/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3/" class="archive-article-date">
  	<time datetime="2021-08-21T13:51:39.982Z" itemprop="datePublished"><i class="icon-clock"></i>2021-08-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">java虚拟机</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2021/08/22/spark%E5%88%86%E5%8C%BA%E6%95%99%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          spark RDD总结-spark-2.4.8
        
      </div>
    </a>
  
  
    <a href="/2021/07/31/spark%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">spark安装教程(yarn模式)</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>









      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2021 John Doe
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>


<script src="/./main.js"></script>



    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 10px;">java虚拟机</a> <a href="/tags/spark%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" style="font-size: 20px;">spark安装教程</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>